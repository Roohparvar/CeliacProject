load("C:/Esmaeil/CeliacProject/BackUp/Meta Data/MetaData_Esmaeil.Rdata")
setwd("C:/Esmaeil/CeliacProject/CeliacProject/Motif")
library(stringdist)
library(dplyr)
library(ggplot2)
# .............................................................................. Libraries
library(stringdist)
library(dplyr)
library(ggplot2)
# .............................................................................. Distance matrix
# Keep a copy of the full metadata separately
metadata <- full_metadata
# Cluster selection
# metadata <- metadata[metadata$cluster == "ILC2/ILTi",]
# Keep only rows where a_cdr3 and b_cdr3 are not NA
metadata <- metadata[!is.na(metadata$a_cdr3) & !is.na(metadata$b_cdr3), ]
# Keep only unique pairs of (a_cdr3, b_cdr3)
pairs <- unique(metadata[, c("a_cdr3", "b_cdr3")])
# dist_a[i, j] = Levenshtein distance between a_cdr3[i] and a_cdr3[j]
dist_a <- stringdistmatrix(pairs$a_cdr3, pairs$a_cdr3, method = "lv")
# dist_b[i, j] = Levenshtein distance between b_cdr3[i] and b_cdr3[j]
dist_b <- stringdistmatrix(pairs$b_cdr3, pairs$b_cdr3, method = "lv")
# Final distance = sum of the two
dist_matrix <- dist_a + dist_b
dist_matrix <- as.matrix(dist_matrix)
# Set rownames and colnames using combined sequences
rownames(dist_matrix) <- paste(pairs$a_cdr3, pairs$b_cdr3, sep = "+")
colnames(dist_matrix) <- paste(pairs$a_cdr3, pairs$b_cdr3, sep = "+")
saveRDS(dist_matrix, file = "dist_matrix.rds")
# .............................................................................. distribution of node degrees
thresholds <- 0:25
num_nonzero_nodes <- numeric(length(thresholds))
for (i in seq_along(thresholds)) {
th <- thresholds[i]
binary_matrix <- ifelse(dist_matrix < th, 1, 0)
diag(binary_matrix) <- 0
nonzero_nodes <- apply(binary_matrix, 1, function(x) any(x != 0))
num_nonzero_nodes[i] <- sum(nonzero_nodes)
}
df <- data.frame(
Threshold = thresholds,
Nonzero_Nodes = num_nonzero_nodes
)
png("nonzero_nodes_vs_threshold.png", width = 2000, height = 1500, res = 300)
ggplot(df, aes(x = Threshold, y = Nonzero_Nodes)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.8) +
theme_minimal() +
labs(x = "Threshold", y = "Number of Nodes", title = "Nodes vs Distance Threshold") +
theme(
plot.title = element_text(hjust = 0.5, size = 9),
axis.title.x = element_text(size = 9),
axis.title.y = element_text(size = 9),
axis.text.x = element_text(size = 7),
axis.text.y = element_text(size = 7)
)
dev.off()
# ..............................................................................
binary_matrix <- ifelse(dist_matrix < 10, 1, 0)
storage.mode(binary_matrix) <- storage.mode(dist_matrix)
saveRDS(binary_matrix, file = "binary_matrix.rds")
# Calculate node degrees (sum of each row or column, since matrix is symmetric)
node_degrees <- rowSums(binary_matrix)
# Create result matrix: node ID + degree
degree_matrix <- cbind(Node = 1:length(node_degrees), Degree = node_degrees)
# Sort by degree descending (most connected nodes first)
degree_matrix <- degree_matrix[order(-degree_matrix[,2]), ]
# Save as a matrix
degree_matrix <- as.matrix(degree_matrix)
# Make degree_matrix a data frame
degree_matrix <- as.data.frame(degree_matrix)
# Assume rownames(degree_matrix) are the clones
degree_matrix$Clone <- rownames(degree_matrix)
# For each clone, get all unique clusters in full_metadata and collapse into one string
cluster_map <- full_metadata %>%
group_by(cdr_Full_ab) %>%
summarise(Cluster = paste(unique(cluster), collapse = ","), .groups = "drop")
# Join with degree_matrix by clone name
degree_matrix <- degree_matrix %>% left_join(cluster_map, by = c("Clone" = "cdr_Full_ab"))
# .............................................................................. Degree Distribution bar plot
degree_counts <- degree_matrix %>% count(Degree, name = "Frequency")
degree_filtered <- subset(degree_counts, Degree < 100)
png("degree_distribution.png", width = 2800, height = 2600, res = 600)
ggplot(degree_filtered, aes(x = Degree, y = Frequency)) +
geom_bar(stat = "identity", width = 0.8, fill = "steelblue") +
theme_minimal() +
labs(x = "Degree", y = "Frequency", title = "Degree Distribution") +
scale_x_continuous(breaks = seq(0, 200, by = 5)) +
theme(
plot.title = element_text(hjust = 0.5, size = 8),   # Center the title
axis.title.x = element_text(size = 8),   # X-axis label
axis.title.y = element_text(size = 8),   # Y-axis label
axis.text.x = element_text(size = 7),    # X-axis numbers
axis.text.y = element_text(size = 7)     # Y-axis numbers
)
dev.off()
nrow(binary_matrix)
colnames(binary_matrix)
ncol(binary_matrix)
binary_matrix <- ifelse(dist_matrix < 10, 1, 0)
diag(binary_matrix) <- 0
storage.mode(binary_matrix) <- storage.mode(dist_matrix)
saveRDS(binary_matrix, file = "binary_matrix.rds")
# Calculate node degrees (sum of each row or column, since matrix is symmetric)
node_degrees <- rowSums(binary_matrix)
# Create result matrix: node ID + degree
degree_matrix <- cbind(Node = 1:length(node_degrees), Degree = node_degrees)
# Sort by degree descending (most connected nodes first)
degree_matrix <- degree_matrix[order(-degree_matrix[,2]), ]
# Save as a matrix
degree_matrix <- as.matrix(degree_matrix)
# Make degree_matrix a data frame
degree_matrix <- as.data.frame(degree_matrix)
# Assume rownames(degree_matrix) are the clones
degree_matrix$Clone <- rownames(degree_matrix)
# For each clone, get all unique clusters in full_metadata and collapse into one string
cluster_map <- full_metadata %>%
group_by(cdr_Full_ab) %>%
summarise(Cluster = paste(unique(cluster), collapse = ","), .groups = "drop")
# Join with degree_matrix by clone name
degree_matrix <- degree_matrix %>% left_join(cluster_map, by = c("Clone" = "cdr_Full_ab"))
# .............................................................................. Degree Distribution bar plot
degree_counts <- degree_matrix %>% count(Degree, name = "Frequency")
degree_filtered <- subset(degree_counts, Degree < 100)
png("degree_distribution.png", width = 2800, height = 2600, res = 600)
ggplot(degree_filtered, aes(x = Degree, y = Frequency)) +
geom_bar(stat = "identity", width = 0.8, fill = "steelblue") +
theme_minimal() +
labs(x = "Degree", y = "Frequency", title = "Degree Distribution") +
scale_x_continuous(breaks = seq(0, 200, by = 5)) +
theme(
plot.title = element_text(hjust = 0.5, size = 8),   # Center the title
axis.title.x = element_text(size = 8),   # X-axis label
axis.title.y = element_text(size = 8),   # Y-axis label
axis.text.x = element_text(size = 7),    # X-axis numbers
axis.text.y = element_text(size = 7)     # Y-axis numbers
)
dev.off()
