setwd("C:/Esmaeil/CeliacProject/CeliacProject/5_Clonal Expansion Analysis/New/ab")
load("C:/Esmaeil/CeliacProject/BackUp/Meta Data/MetaData_Esmaeil.Rdata")
unique(full_metadata$clone_size_ab)
View(full_metadata)
load("C:/Esmaeil/CeliacProject/BackUp/Meta Data/MetaData_Esmaeil.Rdata")
setwd("C:/Esmaeil/CeliacProject/CeliacProject/2_immune receptors distribution/Distribution of TCR Combinations")
library(dplyr)
library(openxlsx)
summary_table <- full_metadata %>%
group_by(cluster) %>%
summarise(
total_cells = n(),  # new column for total number of cells in the cluster
ab = sum(imm_receptor_Esmaeil == "ab", na.rm = TRUE),
Aberrant_ab = sum(imm_receptor_Esmaeil == "Aberrant ab", na.rm = TRUE),
gd = sum(imm_receptor_Esmaeil == "gd", na.rm = TRUE),
Aberrant_g = sum(imm_receptor_Esmaeil == "Aberrant g", na.rm = TRUE),
only_a = sum(!is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3)),
only_b = sum(is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3)),
only_g = sum(is.na(a_cdr3) & is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
only_d = sum(is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
a_b = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3)),
a_g = sum(!is.na(a_cdr3) & is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
a_d = sum(!is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
b_g = sum(is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
b_d = sum(is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
a_b_g = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
a_b_d = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
a_g_d = sum(!is.na(a_cdr3) & is.na(b_cdr3) & !is.na(g_cdr3) & !is.na(d_cdr3)),
b_g_d = sum(is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & !is.na(d_cdr3)),
all_present = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & !is.na(d_cdr3)),
all_a_b_g_d_NA = sum(is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3))
)
# Save to Excel
write.xlsx(summary_table, "cluster_summary.xlsx")
library(dplyr)
library(openxlsx)
# Remove the cluster column (keep only numeric columns for correlation)
numeric_table <- summary_table %>% select(-cluster)
# Calculate correlation matrix
cor_matrix <- cor(numeric_table, use = "pairwise.complete.obs")
# Convert matrix to data frame and add row names as a column
cor_df <- as.data.frame(cor_matrix)
cor_df <- cbind(Column = rownames(cor_df), cor_df)
# Save to Excel
write.xlsx(cor_df, "cluster_correlation_matrix.xlsx", rowNames = FALSE)
library(dplyr)
library(openxlsx)
summary_table <- full_metadata %>%
group_by(cluster) %>%
summarise(
total_cells = n(),  # new column for total number of cells in the cluster
ab = sum(imm_receptor_Esmaeil == "ab", na.rm = TRUE),
Aberrant_ab = sum(imm_receptor_Esmaeil == "Aberrant ab", na.rm = TRUE),
gd = sum(imm_receptor_Esmaeil == "gd", na.rm = TRUE),
Aberrant_g = sum(imm_receptor_Esmaeil == "Aberrant g", na.rm = TRUE),
only_a = sum(!is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3)),
only_b = sum(is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3)),
only_g = sum(is.na(a_cdr3) & is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
only_d = sum(is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
a_b = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3)),
a_g = sum(!is.na(a_cdr3) & is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
a_d = sum(!is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
b_g = sum(is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
b_d = sum(is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
a_b_g = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & is.na(d_cdr3)),
a_b_d = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & is.na(g_cdr3) & !is.na(d_cdr3)),
a_g_d = sum(!is.na(a_cdr3) & is.na(b_cdr3) & !is.na(g_cdr3) & !is.na(d_cdr3)),
b_g_d = sum(is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & !is.na(d_cdr3)),
all_present = sum(!is.na(a_cdr3) & !is.na(b_cdr3) & !is.na(g_cdr3) & !is.na(d_cdr3)),
all_a_b_g_d_NA = sum(is.na(a_cdr3) & is.na(b_cdr3) & is.na(g_cdr3) & is.na(d_cdr3))
)
# Save to Excel
write.xlsx(summary_table, "cluster_summary.xlsx")
library(dplyr)
library(openxlsx)
# Remove the cluster column (keep only numeric columns for correlation)
numeric_table <- summary_table %>% select(-cluster)
# Calculate correlation matrix
cor_matrix <- cor(numeric_table, use = "pairwise.complete.obs")
# Convert matrix to data frame and add row names as a column
cor_df <- as.data.frame(cor_matrix)
cor_df <- cbind(Column = rownames(cor_df), cor_df)
# Save to Excel
write.xlsx(cor_df, "cluster_correlation_matrix.xlsx", rowNames = FALSE)
Tg = full_metadata[full_metadata$cluster=="Tgd",]
View(Tg)
Ok = Tg[!is.na(Tg$cdr_Full_ab) & !is.na(Tg$cdr_Full_gd),]
View(Ok)
target_rows <- (
(
!is.na(full_metadata$cdr_Full_ab) &
full_metadata$cdr_Full_ab != "" &
!is.na(full_metadata$cdr_Full_gd) &
full_metadata$cdr_Full_gd != "" &
(full_metadata$imm_receptor_Esmaeil == "ab" | full_metadata$imm_receptor_Esmaeil == "gd" )
) |
full_metadata$imm_receptor_Esmaeil == "abgd"
)
load("C:/Esmaeil/CeliacProject/BackUp/Meta Data/MetaData_Esmaeil.Rdata")
# Define the logical condition
target_rows <- (
(
!is.na(full_metadata$cdr_Full_ab) &
full_metadata$cdr_Full_ab != "" &
!is.na(full_metadata$cdr_Full_gd) &
full_metadata$cdr_Full_gd != "" &
(full_metadata$imm_receptor_Esmaeil == "ab" | full_metadata$imm_receptor_Esmaeil == "gd")
) |
full_metadata$imm_receptor_Esmaeil == "abgd"
)
# Subset rows based on condition and save in new data frame
new_metadata <- full_metadata[target_rows, ]
View(new_metadata)
target_rows <- (
(
!is.na(full_metadata$cdr_Full_ab) &
full_metadata$cdr_Full_ab != "" &
!is.na(full_metadata$cdr_Full_gd) &
full_metadata$cdr_Full_gd != "" &
(full_metadata$imm_receptor_Esmaeil == "ab" | full_metadata$imm_receptor_Esmaeil == "gd")
) |
full_metadata$imm_receptor_Esmaeil == "abgd"
)
new_metadata == full_metadata[target_rows, ]
new_metadata = full_metadata[target_rows, ]
sum(!is.na(full_metadata$cdr_Full_ab))
sum(full_metadata$cdr_Full_ab != "", na.rm = TRUE)
sum(!is.na(full_metadata$cdr_Full_gd))
sum(full_metadata$cdr_Full_gd != "", na.rm = TRUE)
table(full_metadata$imm_receptor_Esmaeil, useNA = "ifany")
target_rows <- (
(
(
(!is.na(full_metadata$cdr_Full_ab) & full_metadata$cdr_Full_ab != "") |
(!is.na(full_metadata$cdr_Full_gd) & full_metadata$cdr_Full_gd != "")
) &
(full_metadata$imm_receptor_Esmaeil %in% c("ab", "gd", "Aberrant ab", "Aberrant g"))
) |
full_metadata$imm_receptor_Esmaeil == "abgd"
)
new_metadata <- full_metadata[target_rows, ]
View(new_metadata)
View(full_metadata)
target_rows <- !is.na(full_metadata$cdr_Full_ab) & full_metadata$cdr_Full_ab != "" &
!is.na(full_metadata$cdr_Full_gd) & full_metadata$cdr_Full_gd != ""
# Subset those rows
both_metadata <- full_metadata[target_rows, ]
# Quick check
nrow(both_metadata)
head(both_metadata)
View(new_metadata)
View(both_metadata)
View(both_metadata)
unique(both_metadata$imm_receptor_Esmaeil)
View(both_metadata)
table(both_metadata$imm_receptor_Esmaeil)
View(both_metadata)
setwd("C:/Esmaeil/CeliacProject/CeliacProject/shared gd")
load("C:/Esmaeil/CeliacProject/BackUp/Meta Data/MetaData_Esmaeil.Rdata")
full_metadata = full_metadata[full_metadata$cluster == "Tgd" |
full_metadata$cluster == "Tgd CD8+" |
full_metadata$cluster == "NK Tgd" |
full_metadata$cluster == "Tgd INSIG1+" |
full_metadata$cluster == "Trm IEL", ]
View(full_metadata)
setwd("C:/Esmaeil/CeliacProject/CeliacProject/shared gd/in 5 Tgd Clusters")
full_metadata <- full_metadata %>% filter( !is.na(full_metadata$TRGV) & !is.na(full_metadata$TRGV) )
View(full_metadata)
clones_by_cluster <- full_metadata %>%
filter(!is.na(cdr_Full_gd)) %>%      # remove NAs
group_by(cluster) %>%
summarise(clones = list(unique(cdr_Full_gd)))
View(clones_by_cluster)
clones_list <- setNames(clones_by_cluster$clones, clones_by_cluster$cluster)
View(clones_list)
# Convert to UpSet input
upset_data <- fromList(clones_list)
library(dplyr)
library(tidyr)
library(UpSetR)
library(tibble)
# Convert to UpSet input
upset_data <- fromList(clones_list)
View(upset_data)
# Save as PNG
png("shared_clones_Tgd_Clusters.png", width = 2000, height = 2300, res = 300, bg = "white")
upset(upset_data,
nsets = length(clones_list),
nintersects = 20,
order.by = "freq",
mainbar.y.label = "Shared Clones",
sets.x.label = "Clones per Tγδ Clusters")
dev.off()
library(dplyr)
library(tidyr)
library(UpSetR)
library(purrr)
# Prepare clones per cluster (remove NAs)
clones_by_cluster <- full_metadata %>%
filter(!is.na(cdr_Full_ab)) %>%
group_by(cluster) %>%
summarise(clones = list(unique(cdr_Full_ab)))
clones_list <- setNames(clones_by_cluster$clones, clones_by_cluster$cluster)
# Function to get shared clones for any combination of clusters
get_shared_clones <- function(clusters) {
Reduce(intersect, clones_list[clusters])
}
shared_Th_Tregs <- get_shared_clones(c("Th", "Tregs"))
print(shared_Th_Tregs)
# Example: get shared clones between NK Tgd and Trm IEL
shared_Th_Tregs <- get_shared_clones(c("NK Tgd", "Trm IEL"))
print(shared_Th_Tregs)
# ---- Now build ALL intersections ----
cluster_names <- names(clones_list)
all_combos <- unlist(lapply(1:length(cluster_names), function(i) {
combn(cluster_names, i, simplify = FALSE)
}), recursive = FALSE)
shared_clones_all <- map(all_combos, get_shared_clones)
# Combine into a tidy data frame
shared_table <- tibble(
clusters = map_chr(all_combos, ~ paste(.x, collapse = " & ")),
shared_clones = shared_clones_all,
n_shared = map_int(shared_clones_all, length)
)
# View table (which corresponds to the bars in the UpSet plot)
print(shared_table)
View(shared_table)
shared_Th_Tregs <- get_shared_clones(c("Tgd", "Trm IEL", "Tgd CD8+", "Tgd INSIG1+"))
print(shared_Th_Tregs)
shared <- get_shared_clones(c("Tgd", "Trm IEL", "Tgd CD8+", "Tgd INSIG1+"))
print(shared)
shared <- get_shared_clones(c("Tgd", "Trm IEL"))
print(shared)
shared <- get_shared_clones(c("Tgd", "Tgd CD8+"))
print(shared)
shared <- get_shared_clones(c("Tgd", "Tgd INSIG1+"))
print(shared)
library(dplyr)
library(tidyr)
library(UpSetR)
library(tibble)
full_metadata = full_metadata[full_metadata$cluster == "Tgd" |
full_metadata$cluster == "Tgd CD8+" |
full_metadata$cluster == "NK Tgd" |
full_metadata$cluster == "Tgd INSIG1+" |
full_metadata$cluster == "Trm IEL", ]
full_metadata <- full_metadata %>% filter( !is.na(full_metadata$TRGV) & !is.na(full_metadata$TRGV) )
# Create a named list of clones per cluster
clones_by_cluster <- full_metadata %>%
filter(!is.na(cdr_Full_gd)) %>%      # remove NAs
group_by(cluster) %>%
summarise(clones = list(unique(cdr_Full_gd)))
clones_list <- setNames(clones_by_cluster$clones, clones_by_cluster$cluster)
# Convert to UpSet input
upset_data <- fromList(clones_list)
# Save as PNG
png("shared_clones_Tgd_Clusters.png", width = 2000, height = 2300, res = 300, bg = "white")
upset(upset_data,
nsets = length(clones_list),
nintersects = 20,
order.by = "freq",
mainbar.y.label = "Shared Clones",
sets.x.label = "Clones per Tγδ Clusters")
dev.off()
View(clones_by_cluster)
View(clones_by_cluster)
View(clones_list)
View(upset_data)
get_shared_clones <- function(metadata, clusters) {
# فیلتر روی کلاسترهای انتخابی
subset_meta <- metadata %>% filter(cluster %in% clusters,
!is.na(cdr_Full_gd))
# پیدا کردن کلون‌های مشترک
shared_clones <- subset_meta %>%
group_by(cluster) %>%
summarise(clones = list(unique(cdr_Full_gd)), .groups = "drop") %>%
pull(clones) %>%
Reduce(intersect, .)   # اشتراک همه
# برگرداندن متادیتای مربوط به کلون‌های مشترک
result_meta <- subset_meta %>% filter(cdr_Full_gd %in% shared_clones)
return(result_meta)
}
shared_meta <- get_shared_clones(full_metadata,
c("Tgd", "Tgd CD8+", "Trm IEL"))
View(shared_meta)
unique(shared_meta$cdr_Full_gd)
unique(shared_meta$cluster)
get_shared_clones <- function(metadata, clusters) {
subset_meta <- metadata %>%
filter(cluster %in% clusters, !is.na(cdr_Full_gd))
# کلون‌های مشترک یکتا
shared_clones <- subset_meta %>%
group_by(cluster) %>%
summarise(clones = list(unique(cdr_Full_gd)), .groups = "drop") %>%
pull(clones) %>%
Reduce(intersect, .)   # اشتراک
return(shared_clones)   # فقط کلون‌های یکتا
}
shared_meta <- get_shared_clones(full_metadata,
c("Tgd", "Tgd CD8+", "Trm IEL"))
unique(shared_meta$cdr_Full_gd)
shared_meta <- get_shared_clones(full_metadata,
c("Tgd", "Tgd CD8+", "Trm IEL"))
intersect_3 <- Reduce(intersect, clones_list[c("Tgd", "Tgd CD8+", "Trm IEL")])
length(intersect_3)  # تعداد کلون‌های یکتا مشترک (باید با upset یکی باشه
intersect_3 <- Reduce(intersect, clones_list[c("Tgd", "Tgd CD8+", "Trm IEL")])
# بررسی اینکه هر کلون تو چند کلاستر هست
check_clusters <- sapply(intersect_3, function(cl) {
sum(sapply(clones_list, function(clst) cl %in% clst))
})
table(check_clusters)
باشه)
get_exact_shared <- function(clones_list, clusters) {
# کلون‌هایی که در همه‌ی کلاسترهای انتخابی هستند
common <- Reduce(intersect, clones_list[clusters])
# فیلتر کردن: فقط کلون‌هایی که دقیقا در همین کلاسترها ظاهر شدن
exact <- common[sapply(common, function(cl) {
which_sets <- names(which(sapply(clones_list, function(clst) cl %in% clst)))
setequal(sort(which_sets), sort(clusters))
})]
return(exact)
}
exact_shared <- get_exact_shared(clones_list, c("Tgd", "Tgd CD8+", "Trm IEL"))
length(exact_shared)  # باید 6 بشه، مثل UpSetR
exact_shared <- get_exact_shared(clones_list, c("Tgd", "Tgd CD8+", "Tgd INSIG1+"))
length(exact_shared)  # باید 6 بشه، مثل UpSetR
get_exact_shared_metadata <- function(metadata, clones_list, clusters) {
# کلون‌های منحصراً مشترک
common <- Reduce(intersect, clones_list[clusters])
exact <- common[sapply(common, function(cl) {
which_sets <- names(which(sapply(clones_list, function(clst) cl %in% clst)))
setequal(sort(which_sets), sort(clusters))
})]
# فیلتر متادیتا بر اساس همین کلون‌ها
result_meta <- metadata %>% filter(cdr_Full_gd %in% exact)
return(result_meta)
}
new_meta <- get_exact_shared_metadata(full_metadata, clones_list,
c("Tgd", "Tgd CD8+", "Trm IEL"))
View(new_meta)
unique(new_meta$cdr_Full_gd)
unique(new_meta$cluster)
new_meta <- get_exact_shared_metadata(full_metadata, clones_list,
c("Tgd", "Tgd INSIG1+"))
unique(new_meta$cdr_Full_gd)
new_meta <- get_exact_shared_metadata(full_metadata, clones_list,
c("Trm IEL", "Tgd INSIG1+"))
unique(new_meta$cdr_Full_gd)
View(new_meta)
unique(new_meta$clone_size_gd)
